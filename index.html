<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
  <title>HueQue</title>
  <style>
    :root {
      --bg: #0e0f12;
      --panel: #151922;
      --accent: #6dd5ed;
      --text: #e6e6e6;
      --muted: #9aa3b2;
      --vial-width: 64px;
      --vial-gap: 16px;
      --cell-height: 28px;
      --radius: 14px;
      --scale: 1;
      --max-board-width: 1024px;
      --cells: 4;
      --cols: 3; /* dynamic via JS: up to 8 */
    }

    html, body { height: 100%; margin: 0; background: var(--bg); color: var(--text); font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial; }

    .app { display: grid; grid-template-rows: auto 1fr auto; height: 100dvh; max-width: 100vw; }

    header, footer { background: #11141bcc; backdrop-filter: blur(6px); border-bottom: 1px solid #1f2430; border-top: 1px solid #1f2430; }
    header { position: sticky; top: 0; z-index: 100; }
    header { padding: 10px 12px; display: grid; grid-template-columns: 1fr auto 1fr; gap: 8px; align-items: center; }
    .title { font-weight: 700; letter-spacing: 0.3px; opacity: 0.95; }
    .controls { display: flex; gap: 8px; flex-wrap: wrap; justify-content: center; } 
    .hud { display:flex; gap:8px; align-items:center; flex-wrap:nowrap; white-space:nowrap; }
    .right-controls { display: flex; gap: 8px; justify-content: end; align-items: center; min-width: 0; }
    button, select, input[type="range"] { background: var(--panel); color: var(--text); border: 1px solid #252b38; border-radius: 10px; padding: 8px 10px; font-size: 14px; box-shadow: 0 2px 10px #00000030 inset, 0 1px 0 #ffffff10; }
    button:active { transform: translateY(1px); }

    main { overflow: hidden; display: grid; place-items: start center; align-content: start; padding: 4px 8px 8px; }
    .board-wrap { transform-origin: top center; transform: scale(var(--scale)); }

    .board {
      max-width: var(--max-board-width);
      display: grid;
      gap: var(--vial-gap);
      justify-content: center;
      grid-auto-rows: 1fr;
      grid-template-columns: repeat(var(--cols), minmax(var(--vial-width), max-content));
      padding: 12px;
    }

    /* vials: flex column-reverse so array top shows visually at top */
    .vial { width: var(--vial-width); background: linear-gradient(180deg, #1b2231 0%, #141a26 70%); border: 3px solid #0a0f16; border-bottom-width: 12px; border-radius: var(--radius) var(--radius) 12px 12px; box-shadow:
        0 6px 18px rgba(0,0,0,0.45),           /* outer depth */
        inset 0 1px 0 rgba(255,255,255,0.10),   /* top inner highlight */
        inset 0 0 0 1px #2a3647;                /* inner stroke */
      padding: 6px 6px 12px 6px; display: flex; flex-direction: column-reverse; gap: 6px; cursor: pointer; position: relative; touch-action: manipulation; min-height: calc(var(--cell-height) * var(--cells) + (var(--cells) - 1) * 6px); } 
/* Inner rim/lip highlight */
.vial:focus-visible { outline: 2px solid var(--accent); }
    .vial.selected::after { content: ""; position: absolute; inset: -4px; border-radius: 16px; border: 2px solid var(--accent); box-shadow: 0 0 16px #6dd5ed55; pointer-events: none; }

    .cell { height: var(--cell-height); border-radius: 8px; box-shadow: inset 0 -2px 0 #00000033, inset 0 2px 0 #ffffff22; display: grid; place-items: center; font-weight: 800; font-size: 13px; color: #ffffff; text-shadow: 0 1px 2px #000, 0 0 2px #000; user-select: none; position: relative; }
    .cell .mark { font-size: 14px; line-height: 1; filter: drop-shadow(0 1px 1px rgba(0,0,0,.6)); }
    .legend-item { display:inline-flex; align-items:center; gap:6px; }

    footer { padding: 10px 12px; display: flex; gap: 10px; align-items: center; justify-content: space-between; }
    .colors-prev { display: inline-flex; gap: 6px; align-items: center; }
    .swatch { width: 14px; height: 14px; border-radius: 3px; border: 1px solid #0006; box-shadow: inset 0 1px 0 #fff3; }
    .badge { display:inline-block; min-width: 22px; padding: 2px 6px; margin-left: 6px; border-radius: 999px; background:#1e293b; border:1px solid #334155; font-size:12px; text-align:center; }

    @media (max-width: 480px) { :root { --vial-width: 56px; --cell-height: 24px; --vial-gap: 12px; } header, footer { padding: 8px; } button { padding: 8px; } .title { font-size: 14px; } }

    /* Modals */
    .overlay { position: fixed; inset: 0; display: none; align-items: center; justify-content: center; background: #000a; z-index: 200; }
    .overlay.show { display: flex; }
    .card { background: #141a22; border: 1px solid #2b3346; border-radius: 16px; padding: 20px 24px; box-shadow: 0 12px 40px #000a; text-align: center; }
    .card h2 { margin: 0 0 8px 0; }
    .card p { margin: 0 0 16px 0; color: var(--muted); }
  </style>
</head>
<body>
  <div class="app">
    <header>
      <div class="controls">
        <label class="hud" title="Color‚Äëvision accessibility marks">
          CVD Assist:
          <input type="checkbox" id="cvdToggle" />
        </label>
        <button id="newGame">New</button>
        <button id="undoBtn" title="Undo last move (Z)">Undo</button>
        <button id="addVialBtn" title="Spend a token to add an empty vial">+1 Vial <span id="tokenBadge" class="badge">0</span></button>
      </div>
      <div class="right-controls">
        <div class="hud" style="display:flex; gap:8px; align-items:center; flex-wrap:nowrap; flex:1 1 auto; white-space:nowrap;">
          <span class="meter" id="levelMeter">Level 1/12</span>
          <span class="meter" id="moveMeter">Moves: 0 / 0</span>
          <span class="meter" id="zoomMeter">Zoom: 100%</span>
          
        </div>
        <div class="colors-prev" id="legend"></div>
        <input id="zoom" type="range" min="60" max="160" value="100" step="2" />
        <button id="fitBtn">Fit</button>
      </div>
    </header>

    <main>
      <div class="board-wrap">
        <div id="board" class="board" role="grid" aria-label="HueQue board"></div>
      </div>
    </main>

    <!-- Win modal -->
    <div id="winOverlay" class="overlay" aria-hidden="true" role="dialog" aria-label="Win dialog">
      <div class="card">
        <h2>üéâ You Win!</h2>
        <p id="winMsg">You solved it in <strong id="winMoves">0<\/strong> moves.<\/p>
        <div style="display:flex; gap:8px; justify-content:center;">
          <button id="winNext">Next level</button>
        </div>
      </div>
    </div>

    <!-- Confirm modal -->
    <div id="confirmOverlay" class="overlay" aria-hidden="true" role="dialog" aria-label="Confirm new game">
      <div class="card">
        <h2>Give up and start a new game?</h2>
        <p>This will reset HueQue to <strong>3 vials</strong>.</p>
        <div style="display:flex; gap:8px; justify-content:center;">
          <button id="confirmYes">Yes, start over</button>
          <button id="confirmNo">No, keep playing</button>
        </div>
      </div>
    </div>

    
  </div>

  <script>
    // ================= Utilities =================
    const randInt = (min, max) => Math.floor(Math.random() * (max - min + 1)) + min;

    // Palette + Shapes (CVD assist)
    const PALETTE = [
      '#ff6b6b', '#06b6d4', '#ffe66d', '#3b82f6', '#a66ddc',
      '#f7a072', '#28df99', '#c4f1be', '#84d2f6', '#f29e4c',
      '#22c55e', '#f94144', '#577590', '#f8961e', '#43aa8b'
    ];
    const SHAPES = ['‚óè','‚ñ≤','‚óÜ','‚ñ†','‚úö','‚òÖ','‚úï','‚¨ü','‚¨¢','‚ú±','‚¨£','‚ô¶','‚¨§','‚ñ£','‚óã'];

    // ================= State =================
    const state = {
      vials: [],
      history: [],
      selected: null,
      moves: 0,                 // per-level moves
      cumulativeMoves: 0,       // persists until New-confirm
      maxStack: 4,
      numVials: 3,
      cvdAssist: true,
      wins: 0,
      vialTokens: 0,
      zoomPct: 100,
      level: 1,
      maxLevels: 12
    };

    // ================= DOM Refs =================
    const boardEl   = document.getElementById('board');
    const newGameBtn= document.getElementById('newGame');
    const undoBtn   = document.getElementById('undoBtn');
    const addVialBtn= document.getElementById('addVialBtn');
    const tokenBadge= document.getElementById('tokenBadge');
    const moveMeter = document.getElementById('moveMeter');
    const levelMeter= document.getElementById('levelMeter');
    const legendEl  = document.getElementById('legend');
        const zoomRange = document.getElementById('zoom');
    const zoomMeter = document.getElementById('zoomMeter');
    const fitBtn    = document.getElementById('fitBtn');
    const boardWrap = document.querySelector('.board-wrap');
    const winOverlay= document.getElementById('winOverlay');
    const winNext   = document.getElementById('winNext');
    const winMovesEl= document.getElementById('winMoves');
    const winMsg    = document.getElementById('winMsg');
    const confirmOverlay = document.getElementById('confirmOverlay');
    const confirmYes = document.getElementById('confirmYes');
    const confirmNo  = document.getElementById('confirmNo');
    const cvdToggle  = document.getElementById('cvdToggle');

    // Flags
    let justWon = false;
    let hasShownWin = false;

    // ================= Scaling =================
    function applyScale(pct) {
      document.documentElement.style.setProperty('--scale', (pct / 100).toString());
      zoomMeter.textContent = 'Zoom: ' + pct + '%';
      zoomRange.value = String(pct);
    }
    function setScale(pct) { state.zoomPct = pct; applyScale(pct); }
    function computeFitPct() {
      const appRect = document.querySelector('main').getBoundingClientRect();
      const boardRect = boardWrap.getBoundingClientRect();
      const scaleX = Math.min(1, (appRect.width - 12) / Math.max(boardRect.width, 1));
      const scaleY = Math.min(1, (appRect.height - 12) / Math.max(boardRect.height, 1));
      const scale = Math.max(0.6, Math.min(scaleX, scaleY));
      return Math.round(scale * 100);
    }
    function updateGridCols() {
      const cols = Math.min(8, Math.max(1, state.numVials));
      document.documentElement.style.setProperty('--cols', String(cols));
    }

    // ================= Generator (scramble + solver) =================
    function newGame(numVials = state.numVials) {
      hideWin();
      state.numVials = numVials; updateGridCols();
      state.vials = [];
      state.history = [];
      state.moves = 0;          // reset per-level moves
      state.selected = null;

      const numColors = Math.max(1, numVials - 1); // keep one empty vial
      const mix = generateByRandomMix(numVials, numColors);
      state.vials = mix.vials;

      render(getCurrentColors());
      updateHUD();
      requestAnimationFrame(() => applyScale(state.zoomPct));
    }

    function generateByRandomMix(numVials, numColors) {
      function buildSolved() {
        const v = Array.from({ length: numVials }, () => []);
        for (let c = 0; c < numColors; c++) {
          for (let k = 0; k < state.maxStack; k++) v[c].push(c);
        }
        return v;
      }

      const ATTEMPTS = 200;
      const TARGET_BASE = Math.max(20, numColors * state.maxStack * 3);

      for (let attempt = 0; attempt < ATTEMPTS; attempt++) {
        let cur = buildSolved();
        let last = null; // avoid immediate backtrack
        const target = TARGET_BASE + randInt(0, 6);

        for (let t = 0; t < target; t++) {
          const sources = [];
          for (let i = 0; i < numVials; i++) if (cur[i].length > 0) sources.push(i);
          if (sources.length === 0) break;
          const i = sources[randInt(0, sources.length - 1)];

          const dests = [];
          for (let j = 0; j < numVials; j++) if (j !== i && cur[j].length < state.maxStack) dests.push(j);
          if (dests.length === 0) break;
          let j = dests[randInt(0, dests.length - 1)];
          if (last && last[0] === j && last[1] === i) {
            const alt = dests.filter(d => d !== last[0]);
            if (alt.length) j = alt[randInt(0, alt.length - 1)];
          }

          // capacity-only move of a single piece
          cur[j].push(cur[i].pop());
          last = [i, j];
        }

        if (isSolvedConfig(cur)) continue; // don't accept trivially solved
        if (isSolvable(cur)) return { vials: cur };
      }

      // Fallback: minimal displacement from solved
      const fb = buildSolved();
      if (numVials > 1 && fb[0].length) fb[1].push(fb[0].pop());
      return { vials: fb };
    }

    // ================= Solver helpers =================
    function isUniformAndFull(stack) { return stack.length === state.maxStack && stack.every(x => x === stack[0]); }
    function isSolvedConfig(vials) { return vials.every(v => v.length === 0 || isUniformAndFull(v)); }
    function encode(vials) { return vials.map(v => v.join(',')).join('|'); }
    function cloneVials(v) { return v.map(col => col.slice()); }

    function genMovesFrom(vials) {
      const moves = [];
      for (let i = 0; i < vials.length; i++) {
        const from = vials[i];
        if (from.length === 0) continue;
        for (let j = 0; j < vials.length; j++) {
          if (i === j) continue;
          const to = vials[j];
          if (to.length >= state.maxStack) continue;
          const moving = from[from.length - 1];
          const topTo = to[to.length - 1];
          if (topTo == null || topTo === moving) {
            let run = 1;
            for (let k = from.length - 2; k >= 0 && from[k] === moving; k--) run++;
            const free = state.maxStack - to.length;
            moves.push([i, j, Math.min(run, free)]);
          }
        }
      }
      return moves;
    }
    function applyMove(vials, i, j, count) {
      const nv = cloneVials(vials);
      for (let k = 0; k < count; k++) nv[j].push(nv[i].pop());
      return nv;
    }
    function isSolvable(startVials) {
      const startKey = encode(startVials);
      const seen = new Set([startKey]);
      const q = [startVials];
      let nodes = 0; const MAX_NODES = 60000;
      while (q.length) {
        const cur = q.shift();
        if (isSolvedConfig(cur)) return true;
        const moves = genMovesFrom(cur);
        for (let m = 0; m < moves.length; m++) {
          const [i, j, cnt] = moves[m];
          if (cur[j].length === 0 && cur[i].length === cnt && new Set(cur[i]).size === 1) continue; // avoid no-op finalizations
          const nxt = applyMove(cur, i, j, cnt);
          const key = encode(nxt);
          if (!seen.has(key)) { seen.add(key); q.push(nxt); nodes++; if (nodes > MAX_NODES) return false; }
        }
      }
      return false;
    }

    // ================= Rules =================
    function getRunLengthTop(idx) {
      const stack = state.vials[idx];
      if (stack.length === 0) return 0;
      const color = stack[stack.length - 1];
      let n = 0; for (let i = stack.length - 1; i >= 0; i--) { if (stack[i] === color) n++; else break; }
      return n;
    }
    function canMove(fromIdx, toIdx) {
      if (fromIdx === toIdx) return false;
      const from = state.vials[fromIdx];
      const to   = state.vials[toIdx];
      if (from.length === 0) return false;
      const freeSpace = state.maxStack - to.length; if (freeSpace <= 0) return false;
      const movingColor = from[from.length - 1];
      if (to.length === 0) return true; // empty vial is always OK
      const topTo = to[to.length - 1];
      return topTo === movingColor;
    }
    function move(fromIdx, toIdx) {
      if (!canMove(fromIdx, toIdx)) return false;
      state.history.push(JSON.parse(JSON.stringify(state.vials)));
      const from = state.vials[fromIdx];
      const to   = state.vials[toIdx];
      const runLen = getRunLengthTop(fromIdx);
      const freeSpace = state.maxStack - to.length;
      const pour = Math.min(runLen, freeSpace);
      for (let i = 0; i < pour; i++) { to.push(from.pop()); }
      state.moves++;
      state.cumulativeMoves++; // total increments on each pour
      return true;
    }
    function isWin() { return state.vials.every(v => v.length === 0 || (v.length === state.maxStack && v.every(c => c === v[0]))); }

    // ================= Rendering =================
    function updateHUD() {
      moveMeter.textContent = 'Moves: ' + state.moves + ' / ' + state.cumulativeMoves;
      if (levelMeter) levelMeter.textContent = 'Level ' + state.level + '/' + state.maxLevels;
      if (tokenBadge) tokenBadge.textContent = String(state.vialTokens);
      if (addVialBtn) addVialBtn.disabled = state.vialTokens <= 0;
      const won = isWin();
      if (won) showWin();
    }
    function render(colorsForLegend) {
      boardEl.innerHTML = '';
      state.vials.forEach((stack, idx) => {
        const vial = document.createElement('div');
        vial.className = 'vial';
        vial.tabIndex = 0;
        vial.setAttribute('role', 'button');
        vial.setAttribute('aria-label', 'HueQue vial ' + (idx + 1));
        vial.dataset.idx = String(idx);

        stack.forEach(color => {
          const cell = document.createElement('div');
          cell.className = 'cell';
          const paint = (typeof color === 'number') ? PALETTE[color % PALETTE.length] : color;
          cell.style.background = paint;
          if (state.cvdAssist) {
            const idxMark = (typeof color === 'number') ? color : Math.max(0, PALETTE.indexOf(color));
            const mark = document.createElement('span');
            mark.className = 'mark';
            mark.textContent = SHAPES[idxMark % SHAPES.length];
            mark.setAttribute('aria-hidden','true');
            cell.appendChild(mark);
          }
          vial.appendChild(cell);
        });

        if (state.selected && state.selected.vialIdx === idx) vial.classList.add('selected');
        vial.addEventListener('click', onVialClick);
        vial.addEventListener('keydown', (e) => { if (e.key === 'Enter' || e.key === ' ') { e.preventDefault(); onVialClick(e); } });
        boardEl.appendChild(vial);
      });

      // Legend
      legendEl.innerHTML = '';
      if (state.cvdAssist) {
        const presentIdx = new Set();
        state.vials.forEach(v => v.forEach(x => { if (typeof x === 'number') presentIdx.add(x); }));
        Array.from(presentIdx).sort((a,b)=>a-b).forEach(i => {
          const wrap = document.createElement('span'); wrap.className = 'legend-item';
          const s = document.createElement('span'); s.className = 'swatch'; s.style.background = PALETTE[i % PALETTE.length];
          const m = document.createElement('span'); m.textContent = SHAPES[i % SHAPES.length];
          wrap.appendChild(s); wrap.appendChild(m); legendEl.appendChild(wrap);
        });
      } else {
        colorsForLegend.forEach(c => { const s = document.createElement('span'); s.className = 'swatch'; s.style.background = c; legendEl.appendChild(s); });
      }
    }

    // ================= Events =================
    function onVialClick(e) {
      const idx = Number(e.currentTarget.dataset.idx);
      if (state.selected == null) {
        if (state.vials[idx].length === 0) return;
        state.selected = { vialIdx: idx };
      } else {
        const fromIdx = state.selected.vialIdx;
        move(fromIdx, idx);
        state.selected = null;
      }
      render(getCurrentColors());
      updateHUD();
    }
    function getCurrentColors() {
      const present = new Set(state.vials.flat());
      const arr = [];
      for (let i = 0; i < PALETTE.length; i++) { if (present.has(i)) arr.push(PALETTE[i]); }
      present.forEach(v => { if (typeof v === 'string') arr.push(v); });
      return arr;
    }
    function startNewGameWithPossibleBump() {
      let count = state.numVials || 3;
      if (justWon) {
        if (state.level < state.maxLevels) {
          state.level += 1;
          count = count + 1; // +1 vial per new level
        }
        justWon = false;
      }
      state.numVials = count; updateGridCols();
      newGame(count);
    }
    function addEmptyVialNow() {
      if (state.vialTokens <= 0) return;
      state.vialTokens -= 1;
      state.vials.push([]);
      state.numVials += 1;
      updateGridCols();
      render(getCurrentColors());
      updateHUD();
      requestAnimationFrame(() => applyScale(state.zoomPct));
    }

    // ================= Boot & listeners =================
    newGameBtn.addEventListener('click', () => { hideWin(); showConfirm(); });
    undoBtn.addEventListener('click', () => {
      const prev = state.history.pop(); if (!prev) return;
      state.vials = prev;
      state.moves++; // per-level
      state.cumulativeMoves++; // total
      render(getCurrentColors());
      updateHUD();
    });
    if (addVialBtn) addVialBtn.addEventListener('click', addEmptyVialNow);
    zoomRange.addEventListener('input', (e) => setScale(parseInt(e.target.value, 10)));
    fitBtn.addEventListener('click', () => setScale(computeFitPct()));
    if (cvdToggle) { cvdToggle.checked = true; cvdToggle.addEventListener('change', (e) => { state.cvdAssist = e.target.checked; render(getCurrentColors()); updateHUD(); }); }
    window.addEventListener('resize', () => applyScale(state.zoomPct));

    // Modals helpers
    function showWin() {
      if (hasShownWin) return;
      hasShownWin = true; justWon = true;
      state.wins += 1; if (state.wins % 3 === 0) state.vialTokens += 1;

      if (state.level >= state.maxLevels) {
        if (winMsg) winMsg.innerHTML = `üèÜ Congratulations! You completed all levels in <strong>${state.cumulativeMoves}</strong> moves.`;
        if (winNext) winNext.textContent = 'Play Again';
      } else {
        if (winMovesEl) winMovesEl.textContent = String(state.moves);
        if (winMsg) winMsg.innerHTML = `You solved it in <strong>${state.moves}</strong> moves.`;
        if (winNext) winNext.textContent = 'Next level';
      }

      winOverlay.classList.add('show');
      winOverlay.setAttribute('aria-hidden', 'false');
      updateHUD();
    }
    function hideWin() {
      winOverlay.classList.remove('show');
      winOverlay.setAttribute('aria-hidden', 'true');
      hasShownWin = false;
    }
    function showConfirm() { confirmOverlay.classList.add('show'); confirmOverlay.setAttribute('aria-hidden','false'); }
    function hideConfirm() { confirmOverlay.classList.remove('show'); confirmOverlay.setAttribute('aria-hidden','true'); }

    if (winNext) winNext.addEventListener('click', () => {
      hideWin();
      if (state.level >= state.maxLevels) { state.level = 1; state.numVials = 3; }
      startNewGameWithPossibleBump();
    });
    if (confirmYes) confirmYes.addEventListener('click', () => {
      hideConfirm();
      justWon = false; hasShownWin = false;
      state.cumulativeMoves = 0; // Reset T only for brand-new run
      state.level = 1; state.numVials = 3; updateGridCols();
      newGame(3);
    });
    if (confirmNo) confirmNo.addEventListener('click', hideConfirm);

    // Initial boot
    if (cvdToggle) state.cvdAssist = cvdToggle.checked = true;
    updateGridCols();
    newGame(state.numVials);
    state.zoomPct = parseInt(zoomRange.value, 10) || 100; applyScale(state.zoomPct);
    setTimeout(() => applyScale(state.zoomPct), 50);
  </script>
</body>
</html>
